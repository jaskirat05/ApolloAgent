"""
Temporal Activities for ComfyUI Operations

Activities perform the actual work that interacts with external systems.
They can fail and will be automatically retried by Temporal.
"""

import asyncio
import sys
import logging
from pathlib import Path
from typing import Dict, Any, Optional
from datetime import datetime

from temporalio import activity

# Setup logging for WebSocket callbacks (which run in different threads)
logger = logging.getLogger(__name__)

# Add parent to path to import from gateway
sys.path.append(str(Path(__file__).parent.parent))

from gateway.core import load_balancer, image_storage
from gateway.observability import create_log_from_history
from temporal_gateway.workflow_registry import get_registry
from temporal_gateway.clients.comfy import ComfyUIClient
from temporal_gateway.database import (
    get_session,
    create_artifact,
    get_latest_artifact,
    create_transfer,
    update_transfer_status,
)


@activity.defn
async def select_best_server(strategy: str) -> str:
    """
    Activity: Select the best available ComfyUI server

    Args:
        strategy: Selection strategy ("least_loaded", "round_robin", "random")

    Returns:
        Server address with http:// prefix (e.g., "http://procure-x.testmcp.org")

    Raises:
        Exception: If no servers are available
    """
    activity.logger.info(f"Selecting server with strategy: {strategy}")

    # Use existing load balancer
    server_address = load_balancer.get_best_server(strategy=strategy)

    if not server_address:
        raise Exception("No available ComfyUI servers")

    # Ensure server address has http:// prefix for new client
    if not server_address.startswith(('http://', 'https://')):
        server_address = f"http://{server_address}"

    activity.logger.info(f"Selected server: {server_address}")
    return server_address



@activity.defn
async def download_and_store_images(
    server_address: str,
    output_files: list[Dict[str, str]],
    workflow_id: Optional[str] = None
) -> list[Dict[str, str]]:
    """
    Activity: Download generated images/videos from ComfyUI and store locally + DB

    Args:
        server_address: Server address
        output_files: List of output file info from get_server_output_files
        workflow_id: Optional workflow ID to link artifacts to

    Returns:
        List of stored file info with local paths
    """
    activity.logger.info(f"Downloading {len(output_files)} file(s)")

    try:
        client = ComfyUIClient(server_address)
        stored_files = []

        for file_info in output_files:
            filename = file_info['filename']
            subfolder = file_info.get('subfolder', '')
            file_type = file_info.get('type', 'output')

            # Download file
            file_data = await client.download_file(
                filename=filename,
                subfolder=subfolder,
                folder_type=file_type
            )

            # Store locally using image_storage
            import uuid
            file_ext = Path(filename).suffix
            unique_filename = f"{uuid.uuid4().hex[:8]}{file_ext}"
            local_path = image_storage.storage_dir / unique_filename

            local_path.write_bytes(file_data)

            file_dict = {
                "filename": unique_filename,
                "original_filename": filename,
                "local_path": str(local_path),
                "node_id": file_info.get('node_id'),
                "server_address": server_address,
                "downloaded_at": datetime.utcnow().isoformat(),
                "file_size": len(file_data),
                "file_type": _detect_file_type(file_ext),
                "file_format": file_ext.lstrip('.'),
            }

            # If workflow_id provided, save to database
            if workflow_id:
                try:
                    with get_session() as session:
                        artifact = create_artifact(
                            session=session,
                            workflow_id=workflow_id,
                            filename=filename,
                            local_filename=unique_filename,
                            local_path=str(local_path),
                            file_type=file_dict["file_type"],
                            file_format=file_dict["file_format"],
                            file_size=file_dict["file_size"],
                            node_id=file_info.get('node_id'),
                            subfolder=subfolder,
                            comfy_folder_type=file_type,
                            approval_status="auto_approved",
                        )
                        file_dict["artifact_id"] = artifact.id
                        activity.logger.info(f"✓ Saved artifact to DB: {artifact.id}")
                except Exception as db_error:
                    activity.logger.error(f"Failed to save artifact to DB: {db_error}")
                    # Continue even if DB save fails

            stored_files.append(file_dict)

        await client.close()
        activity.logger.info(f"Downloaded {len(stored_files)} file(s)")
        return stored_files

    except Exception as e:
        activity.logger.error(f"Failed to download files: {e}")
        # Don't fail workflow if download fails
        return []


def _detect_file_type(file_ext: str) -> str:
    """Detect file type from extension"""
    ext = file_ext.lower().lstrip('.')
    if ext in ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp']:
        return 'image'
    elif ext in ['mp4', 'avi', 'mov', 'webm', 'mkv']:
        return 'video'
    elif ext in ['mp3', 'wav', 'ogg', 'flac']:
        return 'audio'
    else:
        return 'unknown'


@activity.defn
async def create_execution_log(
    prompt_id: str,
    server_address: str,
    workflow_def: Dict[str, Any],
    history_data: Dict[str, Any]
) -> str:
    """
    Activity: Create execution log file from history

    Args:
        prompt_id: ComfyUI prompt ID
        server_address: Server address
        workflow_def: Original workflow definition
        history_data: ComfyUI history data

    Returns:
        Path to log file
    """
    activity.logger.info(f"Creating log for prompt_id: {prompt_id}")

    try:
        # Use existing log creation
        log_path = create_log_from_history(
            prompt_id=prompt_id,
            server_address=server_address,
            workflow=workflow_def,
            history_data=history_data
        )

        activity.logger.info(f"Log created: {log_path}")
        return str(log_path)

    except Exception as e:
        activity.logger.error(f"Failed to create log: {e}")
        return ""


@activity.defn
async def get_server_output_files(
    server_address: str,
    history_data: Dict[str, Any]
) -> list[Dict[str, str]]:
    """
    Activity: Get output file paths on ComfyUI server (for chain execution)

    Args:
        server_address: ComfyUI server address
        history_data: ComfyUI history data

    Returns:
        List of server file paths (not downloaded locally)
    """
    activity.logger.info(f"Extracting server output files")

    try:
        output_files = []
        outputs = history_data.get('outputs', {})

        for node_id, node_output in outputs.items():
            if 'images' in node_output:
                for img_info in node_output['images']:
                    output_files.append({
                        "filename": img_info['filename'],
                        "subfolder": img_info.get('subfolder', ''),
                        "type": img_info.get('type', 'output'),
                        "node_id": node_id
                    })

        activity.logger.info(f"Found {len(output_files)} output file(s)")
        return output_files

    except Exception as e:
        activity.logger.error(f"Failed to get output files: {e}")
        return []


@activity.defn
async def resolve_chain_templates(
    parameters: Dict[str, Any],
    step_results: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Activity: Resolve Jinja2 templates in parameters using step results

    Args:
        parameters: Parameters with templates like {{ step1.output.video }}
        step_results: Previous step results for context

    Returns:
        Resolved parameters
    """
    activity.logger.info(f"Resolving templates in parameters")

    try:
        from temporal_sdk.chains.interpreter import ChainInterpreter

        interpreter = ChainInterpreter()
        context = interpreter.build_execution_context(step_results)
        resolved = interpreter.resolve_templates(parameters, context)

        activity.logger.info(f"Templates resolved successfully")
        return resolved

    except Exception as e:
        activity.logger.error(f"Failed to resolve templates: {e}")
        raise


@activity.defn
async def evaluate_chain_condition(
    condition: str,
    step_results: Dict[str, Any]
) -> bool:
    """
    Activity: Evaluate a chain step condition

    Args:
        condition: Jinja2 condition expression
        step_results: Previous step results

    Returns:
        True if condition passes, False otherwise
    """
    activity.logger.info(f"Evaluating condition: {condition}")

    try:
        from temporal_sdk.chains.interpreter import ChainInterpreter

        interpreter = ChainInterpreter()
        context = interpreter.build_execution_context(step_results)
        result = interpreter.evaluate_condition(condition, context)

        activity.logger.info(f"Condition evaluated to: {result}")
        return result

    except Exception as e:
        activity.logger.error(f"Failed to evaluate condition: {e}")
        raise


@activity.defn
async def apply_workflow_parameters(
    workflow_name: str,
    parameters: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Activity: Apply parameters to workflow and return workflow JSON

    Args:
        workflow_name: Name of the workflow
        parameters: Parameters to apply

    Returns:
        Workflow JSON with parameters applied
    """
    activity.logger.info(f"Applying parameters to workflow: {workflow_name}")

    try:
        registry = get_registry()
        workflow_json = registry.apply_overrides(workflow_name, parameters)

        activity.logger.info(f"Parameters applied successfully")
        return workflow_json

    except Exception as e:
        activity.logger.error(f"Failed to apply parameters: {e}")
        raise



@activity.defn
async def transfer_outputs_to_input(
    source_server: str,
    target_server: str,
    output_files: list[Dict[str, str]]
) -> list[str]:
    """
    Activity: Transfer output files from source server to target server's input directory

    This enables chaining workflows where:
    - Step 1: SaveImage outputs to source_server/output/ComfyUI_00001_.png
    - Step 2: LoadImage expects target_server/input/ComfyUI_00001_.png

    Args:
        source_server: Source ComfyUI server address (where files currently are)
        target_server: Target ComfyUI server address (where files need to be)
        output_files: List of output file info from previous step

    Returns:
        List of filenames now available in target server's input/ directory
    """
    activity.logger.info(f"Transferring {len(output_files)} file(s) from {source_server} to {target_server}")

    try:
        from temporal_gateway.clients.comfy import ComfyUIClient

        source_client = ComfyUIClient(source_server)
        target_client = ComfyUIClient(target_server)
        transferred_filenames = []

        for file_info in output_files:
            filename = file_info['filename']
            subfolder = file_info.get('subfolder', '')
            file_type = file_info.get('type', 'output')

            activity.logger.info(f"Transferring: {filename} from {source_server}/{file_type}/ to {target_server}/input/")

            # Download from source server
            file_data = await source_client.download_file(
                filename=filename,
                subfolder=subfolder,
                folder_type=file_type
            )

            # Upload to target server's input directory
            upload_result = await target_client.upload_file(
                file_data=file_data,
                filename=filename,
                subfolder=subfolder,
                overwrite=True
            )

            transferred_filenames.append(filename)
            activity.logger.info(f"✓ Transferred: {filename} ({len(file_data)} bytes)")

        await source_client.close()
        await target_client.close()

        activity.logger.info(f"Successfully transferred {len(transferred_filenames)} file(s)")
        return transferred_filenames

    except Exception as e:
        activity.logger.error(f"Failed to transfer files: {e}")
        raise


# ============================================================================
# V3 - Using new dedicated ComfyUI client with hybrid tracking
# ============================================================================

@activity.defn
async def execute_and_track_workflow(
    server_address: str,
    workflow_json: Dict[str, Any],
    workflow_name: Optional[str] = None,
    timeout: float = 1800.0
) -> Dict[str, Any]:
    """
    Activity: Execute workflow using new ComfyUI client with hybrid tracking

    This activity uses the new ComfyUI client that:
    - Runs WebSocket and HTTP polling concurrently
    - Handles fast-completing workflows (race conditions)
    - Returns result from whichever source succeeds first

    Args:
        server_address: ComfyUI server address
        workflow_json: Workflow definition JSON
        workflow_name: Optional workflow name for logging
        timeout: Execution timeout in seconds

    Returns:
        Dict with execution result
    """
    from temporal_gateway.clients.comfy import ComfyUIClient

    activity.logger.info(f"[V3] Executing workflow on {server_address}")
    if workflow_name:
        activity.logger.info(f"[V3] Workflow name: {workflow_name}")

    # Create client
    client = ComfyUIClient(server_address)

    try:
        # Progress callback to send heartbeats
        def on_progress(update):
            try:
                activity.heartbeat({
                    "current_node": update.current_node,
                    "progress": update.progress
                })
            except Exception:
                # Heartbeat may fail - ignore
                pass

        # Execute workflow with tracking
        result = await client.execute_workflow(
            workflow=workflow_json,
            progress_callback=on_progress,
            timeout=timeout
        )

        if result.is_success:
            activity.logger.info(f"[V3] Workflow completed successfully")

            return {
                "status": "completed",
                "prompt_id": result.prompt_id,
                "server_address": server_address,
                "outputs": result.outputs
            }
        else:
            activity.logger.error(f"[V3] Workflow failed: {result.error}")
            return {
                "status": "failed",
                "prompt_id": result.prompt_id,
                "server_address": server_address,
                "error": result.error
            }

    finally:
        await client.close()
